I"<h1 id="insertion-sort">Insertion Sort</h1>
<h2 id="sorting-problem">Sorting Problem</h2>
<ul>
  <li>Input: A sequence of <em>n</em> numbers &lt;$a_{1}, a_{2}, …, a_{n}$&gt;</li>
  <li>Output: A permutation (reordering) of the input sequence, &lt;$b_{1}, b_{2}, …, b_{n}$&gt;, such that $b_{1} \leq b_{2} \leq … \leq b_{n}$</li>
  <li>Instance: &lt;7, 10, 4, 5, 2&gt;
    <h3 id="insertion-sort-background">Insertion Sort-Background</h3>
    <p>Consider the following observations:</p>
  </li>
  <li>A list with one element is sorted</li>
  <li>In general, if we have a sorted list of <em>k</em> items we can insert a new item to create a sorted list of size $(k+1)$
For example, consider this sorted array containing of eight sorted entries.</li>
</ul>

<p>[5, 7, 12, 19, 21, 26, 33, 40]</p>

<ul>
  <li>Suppose we want to insert 14 into this array leaving the resulting array sorted</li>
  <li>Starting at the back, if the number is greater than 14, copy it to the right
    <ul>
      <li>Once an entry less than 14 is found, insert 14 into the resulting vacancy (swap)
        <h3 id="insertion-sort-algorithm">Insertion Sort-Algorithm</h3>
        <p>For any unsorted list:</p>
      </li>
    </ul>
  </li>
  <li>Treat the first element as a sorted list of size 1
Then, given a sorted list of size $k-1$</li>
  <li>Insert the $k^{th}$ item in the unsorted list into the sorted list</li>
  <li>The sorted list is now of size $k$
    <h3 id="insertion-sort-implementation--time-complexity">Insertion Sort-Implementation &amp; Time Complexity</h3>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Type</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">Insertion_Sort</span><span class="p">(</span><span class="n">Type</span> <span class="o">*</span><span class="n">_array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_n</span><span class="p">){</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">_n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="c1">//</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">){</span><span class="c1">//</span>
  <span class="k">if</span><span class="p">(</span><span class="n">_array</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">_array</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">_array</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">_array</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span><span class="c1">//</span>
  <span class="p">}</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>From inside to out: $\Theta(1) O(i) O(n^2)$
total: $O(n^2)$</p>
    <h3 id="insertion-sort-avoid-expensive-swapping">Insertion Sort-Avoid Expensive Swapping</h3>
    <p>Now, swapping is expensive, so we could just temporarily assign the new entry</p>
  </li>
  <li>this reduces assignments by a factor of 3</li>
  <li>speeds up the algorithm by a factor of 2
To minimize implementation time, instead of swap, we try for ‘tmp’ variable. For asymptotic analysis, there is no difference.
    <h3 id="insertion-sort-pseudo-code">Insertion Sort-Pseudo Code</h3>
    <p>Insertion-Sort(A)</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for j=2 to A.length
key = A[j]
// Insert A[j] into the sorted
i = j - 1
while i&gt;0 and A[i] &gt; key
  A[i + 1] = A[i]
  i = i - 1
A[i + 1] = key
</code></pre></div>    </div>
    <h3 id="insertion-sortwithout-swap-implementation">Insertion Sort(without Swap)-Implementation</h3>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Type</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">Insertion_Sort_without_Swap</span><span class="p">(</span><span class="n">Type</span> <span class="o">*</span><span class="n">_array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_n</span><span class="p">){</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">_n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="n">Type</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">_array</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">tmp</span><span class="p">){</span>
    <span class="n">_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">_array</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="n">_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">tmp</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span><span class="n">_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">tmp</span><span class="p">){</span>
  <span class="n">_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong>source</strong>
“K-MOOC 허재필 교수님의 &lt;인공지능을 위한 알고리즘과 자료구조: 이론, 코딩, 그리고 컴퓨팅 사고&gt; 강좌의 7-1 삽입 정렬 중(http://www.kmooc.kr/courses/course-v1:SKKUk+SKKU_46+2020_T1)”</p>
:ET