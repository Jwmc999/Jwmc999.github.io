I":8<h1 id="graph">Graph</h1>
<ul>
  <li>A graph is a data type for storing adjacency relations.
    <ul>
      <li>Objects: a finite set of nodes (or vertices)</li>
      <li>Relationships: a finite set of edges (or arcs, links)
        <h4 id="examples">Examples</h4>
      </li>
    </ul>
  </li>
  <li>Computer networks, Road networks, Circuits, CS curriculum
    <h2 id="undirected-graphs">Undirected Graphs</h2>
  </li>
  <li>We define an <em><strong>undirected graph</strong></em> as a collection of vertices
\(V = \left \{ v_{1}, v_{2}, ..., v_{n} \right \}\)
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>The number of vertices is denoted by $</td>
              <td>V</td>
              <td>= n$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Associated with this is a collection E of unordered pairs ${ v_{i}, v_{j}}$ termed edges which connect the vertices</li>
    </ul>
  </li>
  <li>There are a number of data structures that can be used to implement graphs
    <ul>
      <li>Adjacency matrices</li>
      <li>Adjacency lists</li>
    </ul>
  </li>
  <li>We will assume in this course that a vertex is never adjacent to itself
    <ul>
      <li>For example, ${ v_{1}, v_{2}}$ will not define an edge</li>
    </ul>
  </li>
  <li>The maximum number of edges in an undirected graph is
\(\left | E \right |\leq \binom{\left | V \right |}{2}= \frac{\left | V \right |\left ( \left | V \right |-1 \right )}{2}=O\left ( \left | V \right |^{2} \right )\)
    <h4 id="example-01">Example 01</h4>
  </li>
  <li>Consider this collection of vertices
\(V = \left \{ v_{1}, v_{2}, ..., v_{9} \right \}\)
where $|V| = 9$</li>
</ul>

<p><img src="/_posts/Data-Structure/Lecture3/edge.png" alt="edges" /></p>
<ul>
  <li>Associated with these vertices are $|E| = 5$ edges
\(E = \left \{ \left \{ v_{1}, v_{2} \right \}\left \{ v_{3}, v_{5} \right \} \left \{ v_{4}, v_{8} \right \}\left \{ v_{4}, v_{9} \right \}\left \{ v_{6}, v_{9} \right \}\right \}\)
    <ul>
      <li>The pair ${ v_{j}, v_{k}}$ indicates that both vertex $v_{j}$ is adjacent to vertex $v_{k}$ and vertex $v_{k}$ is adjacent to vertex $v_{j}$
        <h4 id="example-02">Example 02</h4>
      </li>
    </ul>
  </li>
  <li>given the $|V|=n$ vertices
= {A, B, C, D, E, F, G}
and the $|E|=9$ edges</li>
</ul>

<p><img src="/_posts/Data-Structure/Lecture3/exm2.png" alt="exm2" /></p>
<h3 id="degree">Degree</h3>
<ul>
  <li>The degree of a vertex is defined as the number of adjacent vertices
  |degree(A) = degree(D) = degree(C) = 3|
  |degree(B) = degree(E) = 4|
  |degree(F) = 1 degree(G) = 0|</li>
  <li>Those vertices adjacent to a given vertex are its <em>neighbors</em>
    <h3 id="sub-graphs">Sub-Graphs</h3>
  </li>
  <li>A <em>sub-graph</em> of a graph: a subset of the vertices and a subset of the edges that connected the subset of vertices in the original graph</li>
</ul>

<p><img src="/_posts/Data-Structure/Lecture3/subgraph.png" alt="subgraph" /></p>
<h3 id="paths">Paths</h3>
<ul>
  <li>A path in an undirected graph is an ordered sequence of vertices
\(\left \( v_{1}, v_{2}, ..., v_{k} \right \)\)
Where ${ v_{j-1}, v_{j}}$ is an edge for <em>j = l, …, k</em>
    <ul>
      <li>Termed a path from $v_{0}$ to $v_{k}$</li>
      <li>The length of this path is <em>k</em>
        <h4 id="example">Example</h4>
        <p><img src="/_posts/Data-Structure/Lecture3/graphpath.png" alt="graphpath" /></p>
      </li>
    </ul>
  </li>
  <li>A path of length 4</li>
</ul>

<p><img src="/_posts/Data-Structure/Lecture3/graphpath2.png" alt="graphpath2" /></p>
<ul>
  <li>A path of length 5</li>
</ul>

<p><img src="/_posts/Data-Structure/Lecture3/trivialpath.png" alt="trivialpath" /></p>
<ul>
  <li>A <em>trivial</em> path of length 0
    <h3 id="simple-paths">Simple Paths</h3>
  </li>
  <li>A <em>simple path</em> has no repetitions other than perhaps the first and last vertices
(e.g.: A-B-C-A)</li>
  <li>A <em>simple cycle</em> is a simple path of at least two vertices with the first and last vertices equal</li>
  <li><strong>What is the example of “simple cycle”?</strong>
    <h3 id="connectedness">Connectedness</h3>
    <p><img src="/_posts/Data-Structure/Lecture3/connected.png" alt="connected" /></p>
  </li>
  <li>Two vertices $v_{i}$, $v_{j}$ are said to be <em>connected</em> if there exists a path from $v_{i}$ to $v_{j}$</li>
  <li>A graph is connected if there exists a path between any two vertices
    <h3 id="weighted-graphs">Weighted Graphs</h3>
    <p><img src="/_posts/Data-Structure/Lecture3/weight.png" alt="weight" /></p>
  </li>
  <li>A weight may be associated with each edge in a graph
    <ul>
      <li>This could represent distance, energy consumption, cost, etc.</li>
      <li>Such a graph is called a <em>weighted graph</em></li>
      <li>Pictorially, we will represent weights by numbers next to the edges</li>
    </ul>
  </li>
  <li>The <em>length</em> of a path within a weighted graph is the sum of all of the edges which make up the path
    <ul>
      <li>The length of the path (A, D, G) in the above graph is 5.1 + 3.7 = 8.8</li>
    </ul>
  </li>
  <li>Different paths may have different weights
    <ul>
      <li>Another path is (A, C, F, G) with length 1.2 + 1.4 + 4.5 = 7.1</li>
    </ul>
  </li>
  <li>Problem: find the shortest path between two vertices
    <ul>
      <li>Here, the shortest path from A to H is (A, C, F, D, E, G) with length 5.7
        <h3 id="trees">Trees</h3>
      </li>
    </ul>
  </li>
  <li>A graph is a tree if it is connected and there is a unique path between any two vertices
    <ul>
      <li>Three trees on the same eight vertices</li>
    </ul>
  </li>
</ul>

<p><img src="/_posts/Data-Structure/Lecture3/treegraph.png" alt="treegraph" /></p>
<ul>
  <li>Consequences:
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>The number of edges is $</td>
              <td>E</td>
              <td>=</td>
              <td>V</td>
              <td>-1$ ($</td>
              <td>V</td>
              <td>$: number of nodes)</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>The graph is <em>acyclic</em>, that is, it does not contain any cycles</li>
      <li>Adding one more edge must create a cycle</li>
      <li>Removing any one edge creates two disjoint non-empty sub-graphs
        <h3 id="forests">Forests</h3>
      </li>
    </ul>
  </li>
  <li>A forest is any graph that has no cycles</li>
  <li>The collection of the tree. A forest removes the connectedness constraint from the tree.</li>
  <li>Consequences:
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>The number of edges is $</td>
              <td>E</td>
              <td>&lt;</td>
              <td>V</td>
              <td>$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>The number of trees is $</td>
              <td>V</td>
              <td>-</td>
              <td>E</td>
              <td>$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Removing any one edge adds one more tree to the forest</li>
    </ul>
  </li>
  <li>
    <p>Here is a forest with 22 vertices and 18 edges</p>

    <p><img src="/_posts/Data-Structure/Lecture3/forest.png" alt="forest" /></p>
    <ul>
      <li>
        <h2 id="there-are-four-trees">There are four trees</h2>
        <h2 id="directed-graphs">Directed Graphs</h2>
      </li>
    </ul>
  </li>
  <li>In a <em><strong>directed graph</strong></em>, the edges on a graph are be associated with a direction
    <ul>
      <li>Edges are ordered pairs $(v_{j}, v_{k})$ denoting a connection from $v_{j}$ to $v_{k}$</li>
      <li>The edge $(v_{j}, v_{k})$ is different from the edge $(v_{k}, v_{j})$
        <h4 id="example-1">Example</h4>
        <p><img src="/_posts/Data-Structure/Lecture3/directed.png" alt="directed" /></p>
      </li>
    </ul>
  </li>
  <li>Given our graph of nine vertices $V = \left { v_{1}, v_{2}, …, v_{9} \right }$$
    <ul>
      <li>These six pairs $(v_{k}, v_{j})$ are <em>directed edges</em>
\(E = \left \{ \left \{ v_{1}, v_{2} \right \}\left \{ v_{3}, v_{5} \right \} \left \{ v_{5}, v_{3} \right \}\left \{ v_{6}, v_{9} \right \}\left \{ v_{8}, v_{4} \right \}\left \{ v_{9}, v_{4} \right \}\right \}\)
        <h3 id="in-and-out-degrees">In and Out Degrees</h3>
      </li>
    </ul>
  </li>
  <li>The degree of a vertex must be modified to consider both cases:
    <ul>
      <li>The <em>out-degree</em> of a vertex is the number of vertices which are adjacent to the given vertex</li>
      <li>The <em>in-degree</em> of a vertex is the number of vertices which this vertex is adjacent to</li>
    </ul>
  </li>
  <li>In this graph:(needs to be updated)
in_degree($v_{1}$) = 0 | out_degree($v_{1}$) = 2
in_degree($v_{5}$) = 2 | out_degree($v_{5}$) = 3
    <h3 id="sources-and-sinks">Sources and Sinks</h3>
  </li>
  <li>Sources and Sinks
    <ul>
      <li>Vertices with an in-degree of zero are described as <em>sources</em></li>
      <li>Vertices with an out-degree of zero are described as <em>sinks</em></li>
    </ul>
  </li>
  <li>In this graph:
    <ul>
      <li>Sources: $v_{1}$, $v_{6}$, $v_{7}$</li>
      <li>Sinks: $v_{2}$, $v_{7}$
        <h3 id="paths-1">Paths</h3>
      </li>
    </ul>
  </li>
  <li>A path in a directed graph is an ordered sequence or vertices
   \(\left \( v_{1}, v_{2}, ..., v_{k} \right \)\)
where ${ v_{j-1}, v_{j}}$ is an edge for <em>j = l, …, k</em></li>
  <li>A path of length 5 in this graph is
 \(\left \( v_{1}, v_{4}, v_{5}, v_{3}, v_{5}, v_{2} \right \)\)</li>
  <li>A simple cycle of length 3 is
\(\left \( v_{8}, v_{4}, v_{5}, v_{8} \right \)\)
    <h3 id="connectedness-1">Connectedness</h3>
  </li>
  <li>Two vertices \(v_{j}\), \(v_{k}\) are said to be <em>connected</em> if there exists a path from $v_{j}$ to $v_{k}$
    <ul>
      <li>A graph is <em>strongly connected</em> if there exists a directed path between any two vertices</li>
      <li>A graph is <em>weakly connected</em> if there exists a path between any two vertices that ignores the direction</li>
    </ul>
  </li>
  <li>In this graph:
    <ul>
      <li>The sub-graph ${ v_{3}, v_{4}, v_{5}, v_{8}}$ is strongly connected</li>
      <li>The sub-graph  ${ v_{1}, v_{2}, v_{3}, v_{4}, v_{5}, v_{8}}$ is weakly connected
        <h3 id="weighted-directed-graphs">Weighted Directed Graphs</h3>
        <p><img src="/_posts/Data-Structure/Lecture3/weighteddirected.png" alt="weightdirect" /></p>
      </li>
    </ul>
  </li>
  <li>In a weighted directed graphs, each edges is associated with a value</li>
  <li>Unlike weighted undirected graphs, if both $( v_{j}, v_{k})$ and $( v_{k}, v_{j})$ are edges, it is not required that they have the same weight
    <h3 id="directed-acyclic-graphs-dag">Directed Acyclic Graphs (DAG)</h3>
  </li>
  <li>A directed <em>acyclic graph</em> is a directed graph which has no cycles
    <ul>
      <li>These are commonly referred to as DAGs</li>
      <li>They are graphical representations of partial orders on a finite number of elements</li>
    </ul>
  </li>
  <li>
    <p>These two are DAGs:</p>

    <h2><img src="/_posts/Data-Structure/Lecture3/DAG.png" alt="DAG" /></h2>
    <h1 id="representations">Representations</h1>
  </li>
  <li>How do we store the adjacency relations?
    <ul>
      <li>Binary-relation list</li>
      <li>Adjacency matrix</li>
      <li>Adjacency list
        <h2 id="binary-relation-list">Binary-Relation List</h2>
      </li>
    </ul>
  </li>
  <li>The most inefficient is a relation list:
    <ul>
      <li>A container storing the edges</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Requires $Theta(</td>
              <td>E</td>
              <td>)$ memory</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Determining if $v_{j}$ is adjacent to $v_{k}$ is $Theta(</td>
              <td>E</td>
              <td>)$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Finding all neighbors of $v_{j}$ is $Theta(|E|)$
        <h2 id="adjacency-matrix">Adjacency Matrix</h2>
      </li>
    </ul>
  </li>
  <li>Requiring more memory but also faster, an adjacency matrix
    <ul>
      <li>The matrix entry (<em>j</em>, <em>k</em>) is set to <strong>true</strong> if there is an edge $( v_{j}, v_{k})$</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Requires $Theta(</td>
              <td>V</td>
              <td>^{2})$ memory</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Determining if $v_{j}$ is adjacent to $v_{k}$ is $Theta(1)$</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Finding all neighbors of $v_{j}$ is $Theta(</td>
              <td>V</td>
              <td>)$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Most efficient for existence of an edge between $v_{j}$ and $v_{k}$</li>
    </ul>
  </li>
  <li>Adjacency matrix of a weighted graph:
    <ul>
      <li>Put the weight value to the cell</li>
    </ul>

    <p><img src="/_posts/Data-Structure/Lecture3/adjmat.png" alt="adjmatrix" /></p>
    <h2 id="adjacency-list">Adjacency List</h2>
  </li>
  <li>Most efficient for algorithms is an adjacency list
    <ul>
      <li>Each vertex is associated with a list of its neighbors</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Requires $Theta(</td>
              <td>V</td>
              <td>+</td>
              <td>E</td>
              <td>)$ memory</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>

    <p><img src="/_posts/Data-Structure/Lecture3/adjlist.png" alt="adjlist" /></p>
  </li>
</ul>

<p><strong>source</strong>
“K-MOOC 허재필 교수님의 &lt;인공지능을 위한 알고리즘과 자료구조: 이론, 코딩, 그리고 컴퓨팅 사고&gt;
강좌의 3-2 강좌의 목표와 실습 환경 중(http://www.kmooc.kr/courses/course-v1:SKKUk+SKKU_46+2020_T1)”</p>

<p><a href="/Lc3/Summary01/">back</a>
<a href="/Lc4/Summary01/">next</a></p>
:ET