I"VC<h2 id="control-statements">Control Statements</h2>
<ul>
  <li>These are statements which potentially alter the execution of instructions
    <ul>
      <li>Conditional statements
        <ul>
          <li>if, switch</li>
        </ul>
      </li>
      <li>Condition-controlled loops
        <ul>
          <li>for, while, do-while</li>
        </ul>
      </li>
      <li>Count-controlled loops
        <ul>
          <li>for i from 1 to 10 do … end do; #Maple</li>
        </ul>
      </li>
      <li>Collection-controlled loops
        <ul>
          <li>foreach(int i in array){ … } //C#</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Given
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">//true body</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="c1">//false body</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>The runtime of a conditional statement is:</li>
  <li>the run time of the condition (the test), plus</li>
  <li>the run time of the body which is run</li>
  <li>
    <p>In most cases, the run time of the condition is $\Theta(1)$ (constant)
<img src="/assets/cont.png" alt="cont" /></p>
  </li>
  <li>
    <p>In some cases, it is easy to determine which statement must be run:
<img src="/assets/others.png" alt="others" /></p>
  </li>
  <li>In others, it is less obvious
<strong>if vs. switch</strong></li>
  <li>Switch statements appear to be nested if statements:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
<span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="cm">/* do stuff */</span> <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="cm">/* do other stuff */</span> <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="cm">/* do even more stuff */</span> <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">4</span><span class="p">:</span> <span class="cm">/* well, do stuff */</span> <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">5</span><span class="p">:</span> <span class="cm">/* tired yet? */</span> <span class="k">break</span><span class="p">;</span>
<span class="nl">default:</span> <span class="cm">/* do default stuff */</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Thus, a switch statement would appear to run in $O(n)$ time where <em>n</em> is the number of cases, the same as nested if Statements</li>
  <li>Why then not use:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">){</span><span class="cm">/* do stuff */</span><span class="p">}</span>
  <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">2</span><span class="p">)(</span><span class="cm">/* do other stuff */</span><span class="p">)</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">3</span><span class="p">)(</span><span class="cm">/* do even more stuff */</span><span class="p">)</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">4</span><span class="p">)(</span><span class="cm">/* well, do stuff */</span><span class="p">)</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">5</span><span class="p">){</span><span class="cm">/* tired yet? */</span><span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span><span class="cm">/* do default stuff */</span><span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Switch statements were included in the original C language. Why would you introduce something into programming language which is redundant?</li>
  <li>First, you may recall that the cases must be actual values, either:
    <ul>
      <li>integers</li>
      <li>characters</li>
    </ul>
  </li>
  <li>For example, you cannot have a case with a variable, e.g.,
    <ul>
      <li>case n: /* do something */ break; //bad</li>
    </ul>
  </li>
  <li>The compiler looks at the different cases and calculates an appropriate jump</li>
  <li>For instance, assume:
    <ul>
      <li>the cases are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</li>
      <li>each case requires a maximum of 24 bytes (for example, six instructions)</li>
      <li>Then the compiler simply makes a jump size based on the variable, jumping ahead either 0, 24, 48, 72, …, or 240 instructions
        <h2 id="analysis-of-statements">Analysis of Statements</h2>
      </li>
    </ul>
  </li>
  <li>In this case, we do not know</li>
  <li>If we had information about the distribution of the entries of the array, we may be able to determine it</li>
  <li>if the list is sorted (ascending) it will always be run</li>
  <li>if the list is sorted (descending) it will be run once</li>
  <li>if the list is uniformly randomly distributed, then?</li>
  <li>It will be discussed at the end of this topic
    <h3 id="condition-controlled-loops">Condition-controlled loops</h3>
  </li>
  <li>The initialization, condition, and increment usually are single statements running in $\Theta(1)$
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">//... code which is $\Theta(f(n))$</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>Assuming there are no break or return statements in the loop, the run time is $\Omega(n)$</p>
  </li>
  <li>If the body does not depend on the variable (in this example, i), then the run time of for() is $\Theta(n f(n))$</li>
  <li>If the body is \(O(f(n))\), then the run time of the loop is \(O(n f(n))\)
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="n">sum</span> <span class="o">+=</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//$$\Theta(1)$$ (constant)</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>This code has run time: \(\Theta(n\cdot 1)=\Theta(n)\) (linear time)</p>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">//n times</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
  <span class="n">sum</span> <span class="o">+=</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//$\Theta(1)$ (constant) n times</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>This code has run time: $\Theta(n\cdotn\cdot1)=\Theta(n^2)$</p>
    <h2 id="analysis-of-repetition-statements">Analysis of Repetition Statements</h2>
  </li>
  <li>Suppose with each loop, we use a linear search an array of size <em>m</em>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="c1">//search through an array of size m</span>
<span class="c1">//$O(m)$;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>In the worst case, the complexity of this search would looking at all <em>m</em> values, but it could end early. Therefore Big O notation rather than $\Theta$.</p>
  </li>
  <li>The inner loop is $O(m)$ and thus the outer loop is $O(nm)$</li>
  <li>If the body depends on the variable (in this example, i), then the run time of
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="c1">//code which is $\Theta(f(i, n))$</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>is \(\Theta \left ( 1+\sum_{i=0}^{n-1}1+f(i, n) \right )\)</p>
  </li>
  <li>
    <dl>
      <dt>If the body is $O(f(i,n))$, the result is \(O \left ( 1+\sum_{i=0}^{n-1}1+f(i,n) \right )\)</dt>
      <dd>The code at the inner loop may sometimes be dependent on i, the variable that controls the loop. This is just a loop regarding i, we can represent how many times the operation is running with sigma.
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
<span class="n">sum</span> <span class="o">+=</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </dd>
    </dl>
  </li>
  <li>The inner is $O(1+i(1+1))=\Theta(i)$ hence the outer is \(\Theta \left ( 1+\sum_{i=0}^{n-1}1+i \right )=\Theta \left ( 1+n+\sum_{i=0}^{n-1}i \right )=\Theta \left ( 1+n+\frac{n(n-1)}{2} \right )=\Theta(n^2)\)
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">){</span>
    <span class="n">sum</span> <span class="o">+=</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span><span class="c1">//const</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>From inside to out:
$\Theta(1) \Theta(j) \Theta(i^2) \Theta(n^3)$
    <h2 id="serial-statements">Serial Statements</h2>
    <p>Consider the following two problems:</p>
    <ul>
      <li>search through a random list of size <em>n</em> to find the maximum entry, and</li>
      <li>search through a random list of size <em>n</em> to find if it contains a particular entry
What is the proper means of describing the run time of these two algorithms?</li>
      <li>Searching for the maximum entry requires that each element in the array be examined, thus, it must run in $\Theta(n)$ time</li>
      <li>Searching for a particular entry may end earlier:
for example, the first entry we are searching for may be the one we are looking for, thus, it runs in $O(n)$ time
(worst case scenario: n times)
Therefore,</li>
      <li>If the leading term is $\Theta$, then the result must be $\Theta$, otherwise</li>
      <li>Of the leading term is big-O, we can say the result is big-O:
for example,</li>
      <li>$O(n)+O(n^2)+O(n^4)=O(n+n^2+n^4)=O(n^4)$</li>
      <li>$O(n)+\Theta(n^2)=\Theta(n^2)$</li>
      <li>$O(n^2)+\Theta(n)=O(n^2)$</li>
      <li>$O(n^2)+\Theta(n^2)=\Theta(n^2)$
        <h2 id="functions">Functions</h2>
        <p>A function (or subroutine) is code which has been separated out, either to:</p>
      </li>
    </ul>
  </li>
  <li>repeated operations</li>
  <li>e.g., mathematical functions</li>
  <li>group related tasks</li>
  <li>e.g., initialization
Because a subroutine (function) can be called from anywhere, we must:</li>
  <li>prepare the appropriate environment</li>
  <li>deal with arguments (parameters)</li>
  <li>jump to the subroutine</li>
  <li>execute the subroutine</li>
  <li>deal with the return value</li>
  <li>clean up
Fortunately, this is such a common task that all modern processors have instructions that perform most of these steps in one instruction.</li>
  <li>Thus, we will assume that the overhead required to make a function call and to return is $\Theta(1)$</li>
  <li>Because any function requires the overhead of a function call and return, we will always assume that $T_{f}=\Omega (1)$</li>
  <li>That is, it is impossible for any function call to have a zero run time</li>
  <li>Thus, given a function $f(n)$ (the run time of which depends on <em>n</em>) we will associate the run time of $f(n)$ by some function $T_{f}(n)$
    <ul>
      <li>We may write this to $T(n)$</li>
    </ul>
  </li>
  <li>Because the run time of any function is at least $O(1)$, we will include the time required to both call and return from the function in the run time</li>
</ul>

<p><strong>source</strong>
“K-MOOC 허재필 교수님의 &lt;인공지능을 위한 알고리즘과 자료구조: 이론, 코딩, 그리고 컴퓨팅 사고&gt; 강좌의 6-2 알고리즘의 복잡도 분석 중(http://www.kmooc.kr/courses/course-v1:SKKUk+SKKU_46+2020_T1)”</p>

<p><a href="/Lc6/Summary01/">back</a>
<a href="/Lc7/Summary01/">next</a></p>
:ET