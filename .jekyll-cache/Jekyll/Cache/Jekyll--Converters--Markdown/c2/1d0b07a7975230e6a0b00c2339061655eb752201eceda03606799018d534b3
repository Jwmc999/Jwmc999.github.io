I"	2<h1 id="merge-sort">Merge Sort</h1>
<p>The merge sort algorithm is defined recursively:</p>
<ul>
  <li>If the list is of size 1, it is sorted-we are done;</li>
  <li>Otherwise:</li>
  <li>Divide an unsorted list into two sub-lists,</li>
  <li>Sort each sub-list recursively using merge sort, and</li>
  <li>Merge the two sorted sub-lists into a single sorted list
This is the first significant divide-and-conquer algorithm we will see.</li>
  <li>Question: How quickly can we recombine the two sub-lists into a single sorted list?
    <h2 id="merging-example">Merging Example</h2>
    <p>Merge sort contains three things:
    - 2 sub-array already sorted,
    - 1 combined, merged array that has the output of the 2 sub-array.<br />
1) Consider the two sorted arrays and an empty array.
[3, 5, 18, 21, 24, …]
[2, 7, 12, 16, 33, …]
[                     ]
2) Define three indices at the start of each array.
3) Compare 2 and 3: 2 &lt; 3</p>
    <ul>
      <li>Copy 2 down</li>
      <li>Increment the corresponding indices
Compare 3 and 7: 3 &lt; 7</li>
      <li>Copy 3 down</li>
      <li>Increment the corresponding indices
Compare 5 and 7: 5 &lt; 7</li>
      <li>Copy 5 down</li>
      <li>Increment the corresponding indices
Compare 18 and 7: 7 &lt; 18</li>
      <li>Copy 7 down</li>
      <li>Increment the corresponding indices
Compare 18 and 12: 12 &lt; 18</li>
      <li>Copy 12 down</li>
      <li>Increment the corresponding indices
Compare 18 and 16: 16 &lt; 18</li>
      <li>Copy 16 down</li>
      <li>Increment the corresponding indices
Compare 33 and 18: 18 &lt; 33</li>
      <li>Copy 18 down</li>
      <li>Increment the corresponding indices
Compare 21 and 33: 21 &lt; 33</li>
      <li>Copy 21 down</li>
      <li>Increment the corresponding indices
Compare 24 and 33: 24 &lt; 33
        <ul>
          <li>Copy 24 down</li>
          <li>Increment the corresponding indices
4) Continue until we have passed beyond the limit of one of the two arrays.
== One of the sub-arrays gets ended (copied every element from 3 to 31 and there’s no more elements to compare in this sub-array)
5) Copy over all remaining entries in the non-empty array (copy from 33 to 42 sequentially from the second sub-array to the result array)
            <h3 id="merging-two-sorted-arrays">Merging Two (Sorted) Arrays</h3>
            <p>Programming a merge is straight-forward:</p>
          </li>
        </ul>
      </li>
      <li>the sorted arrays, arrayA and arrayB, are of size nA and nB, respectively, and</li>
      <li>we have an empty array, arrayOut, of size nA+nB</li>
      <li>define three variables, posA = 0, posB = 0, k = 0; which index into these three arrays
        <h3 id="implementation">Implementation</h3>
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Type</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">Merge</span><span class="p">(</span><span class="n">Type</span> <span class="o">*</span><span class="n">_arrayA</span><span class="p">,</span> <span class="n">Type</span> <span class="o">*</span><span class="n">_arrayB</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_nA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_nB</span><span class="p">,</span> <span class="n">Type</span> <span class="o">*</span><span class="n">_arrayOut</span><span class="p">){</span>
<span class="kt">int</span> <span class="n">posA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">posB</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">posA</span> <span class="o">&lt;</span> <span class="n">_nA</span> <span class="o">&amp;&amp;</span> <span class="n">posB</span> <span class="o">&lt;</span> <span class="n">_nB</span><span class="p">){</span>
<span class="k">if</span><span class="p">(</span><span class="n">_arrayA</span><span class="p">[</span><span class="n">posA</span><span class="p">]</span><span class="o">&lt;</span> <span class="n">_arrayB</span><span class="p">[</span><span class="n">posB</span><span class="p">]){</span>
  <span class="n">_arrayOut</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_arrayA</span><span class="p">[</span><span class="n">posA</span><span class="p">];</span>
  <span class="n">posA</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span><span class="p">{</span>
  <span class="n">_arrayOut</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_arrayB</span><span class="p">[</span><span class="n">posB</span><span class="p">];</span>
  <span class="n">posB</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">posA</span> <span class="o">&lt;</span> <span class="n">_nA</span><span class="p">;</span> <span class="n">posA</span><span class="o">++</span><span class="p">){</span>
<span class="n">_arrayOut</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_arrayA</span><span class="p">[</span><span class="n">posA</span><span class="p">];</span>
<span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">posB</span><span class="o">&lt;</span> <span class="n">_nB</span><span class="p">;</span> <span class="n">posB</span><span class="o">++</span><span class="p">){</span>
<span class="n">_arrayOut</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_arrayB</span><span class="p">[</span><span class="n">posB</span><span class="p">];</span>
<span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>        </div>
        <h3 id="problem-of-merging">Problem of Merging</h3>
        <p>We cannot merge two arrays in-place</p>
      </li>
      <li>This algorithm always require the allocation of a new array
        <h3 id="merge-sort-algorithm">Merge Sort-Algorithm</h3>
        <p>1) Split the list into two approximately equal sub-lists
2) Recursively call merge sort on both sub lists
3) Merge the resulting sorted lists
Merge-Sort(A, p, r)</p>
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if p &lt; r
 q = [(p + r)/2]
 Merge-Sort(A, p, q)
 Merge-Sort(A, q+1, r)
 Merge(A, p, q, r)
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>Question:
We split the list into two sub-lists and sort them. How should we sort these lists?</li>
  <li>Answer(theoretical):
    <ul>
      <li>If the side of these sub-lists is &gt;1, use merge sort again</li>
      <li>If the sub-lists are of length 1, do nothing; a list of length one is sorted</li>
    </ul>
  </li>
  <li>Answer(practical):
    <ul>
      <li>If the sub-lists are less than some threshold length, use an algorithm like insertion sort to sort the lists</li>
      <li>Otherwise, use merge sort, again
        <h3 id="merge-sort-implementation">Merge Sort-Implementation</h3>
        <p>Suppose that we already have a function</p>
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Type</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Merge</span><span class="p">(</span><span class="n">Type</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">midpoint</span> <span class="p">,</span><span class="kt">int</span> <span class="n">last</span><span class="p">)</span>
</code></pre></div>        </div>
        <p>that assumes that the entries</p>
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array[first] through array[midpoint - 1], and
array[midpoint] through array[last - 1]
</code></pre></div>        </div>
        <p>are sorted and merges these two sub-arrays into a single sorted array from index ‘first’ though index ‘last-1’.
We will therefore implement a function</p>
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Type</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Merge_Sort</span><span class="p">(</span><span class="n">Type</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">)</span>
</code></pre></div>        </div>
        <p>that will sort the entries in the positions $first \leq i &lt; last $
If the number of entries is less than $n_{T}$, call insertion sort
Otherwise:</p>
      </li>
      <li>Find the mid-point</li>
      <li>Call merge sort recursively on each of the halves, and</li>
      <li>Merge the results
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Type</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">Merge_Sort</span><span class="p">(</span><span class="n">Type</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">){</span>
<span class="k">if</span><span class="p">(</span><span class="n">_last</span> <span class="o">-</span> <span class="n">_first</span> <span class="o">&lt;=</span> <span class="n">NUM_THRESHOLD</span><span class="p">){</span>
<span class="n">Insertion_Sort</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_array</span><span class="p">,</span> <span class="n">_first</span><span class="p">,</span> <span class="n">_last</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span><span class="p">{</span>
<span class="kt">int</span> <span class="n">midpoint</span><span class="o">=</span><span class="p">(</span><span class="n">_first</span> <span class="o">+</span> <span class="n">_last</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

<span class="n">Merge_Sort</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_array</span><span class="p">,</span> <span class="n">_first</span><span class="p">,</span> <span class="n">midpoint</span><span class="p">);</span>
<span class="n">Merge_Sort</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_array</span><span class="p">,</span> <span class="n">midpoint</span><span class="p">,</span> <span class="n">_last</span><span class="p">);</span>
<span class="n">Merge</span><span class="p">(</span><span class="n">_array</span><span class="p">,</span> <span class="n">_first</span><span class="p">,</span> <span class="n">midpoint</span><span class="p">,</span> <span class="n">_last</span><span class="p">);</span>
<span class="p">}</span>  
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<p><strong>source</strong>
“K-MOOC 허재필 교수님의 &lt;인공지능을 위한 알고리즘과 자료구조: 이론, 코딩, 그리고 컴퓨팅 사고&gt; 강좌의 7-2 합병 정렬과 재귀적 알고리즘의 복잡도 분석 중(http://www.kmooc.kr/courses/course-v1:SKKUk+SKKU_46+2020_T1)”</p>

<p><a href="/Lc7/Summary01/">back</a></p>
:ET